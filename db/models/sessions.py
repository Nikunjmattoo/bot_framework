"""
Sessions model - Updated with Brain state support.
"""
from sqlalchemy import Column, UUID, ForeignKey, Boolean, String, Text, Integer
from sqlalchemy.sql import func
from sqlalchemy.types import TIMESTAMP
from sqlalchemy.dialects.postgresql import JSONB
from sqlalchemy.orm import relationship

from db.models.base import Base


class SessionModel(Base):
    __tablename__ = 'sessions'
    
    id = Column(UUID, primary_key=True, server_default=func.gen_random_uuid())
    user_id = Column(UUID, ForeignKey('users.id', ondelete='CASCADE'), nullable=False)
    instance_id = Column(UUID, ForeignKey('instances.id', ondelete='SET NULL'), nullable=True)
    started_at = Column(TIMESTAMP(timezone=True), nullable=True)
    ended_at = Column(TIMESTAMP(timezone=True), nullable=True)
    active = Column(Boolean, nullable=False, server_default='true')
    source = Column(String, nullable=True)
    last_message_at = Column(TIMESTAMP(timezone=True), nullable=True)
    last_assistant_message_at = Column(TIMESTAMP(timezone=True), nullable=True)
    current_turn = Column(Integer, nullable=False, server_default='0')
    rollup_cursor_at = Column(TIMESTAMP(timezone=True), nullable=True)
    token_plan_json = Column(JSONB, nullable=True)
    
    # ========================================
    # Brain & Orchestrator fields
    # ========================================
    
    # Wire 8: Session summary (generated by cold path)
    session_summary = Column(
        Text, 
        nullable=True,
        comment="Compressed conversation summary (~500 tokens) for context"
    )
    
    # Brain state - stores 6 wires as JSONB:
    # - expecting_response (bool)
    # - answer_sheet (object)
    # - active_task (object)
    # - previous_intents (array)
    # - conversation_context (object)
    # - available_signals (array)
    state = Column(
        JSONB, 
        nullable=False, 
        server_default='{}',
        comment="Brain state containing 6 wires for intent detection"
    )
    
    # Brain output
    next_narrative = Column(
        Text, 
        nullable=True,
        comment="Next message context from brain"
    )
    
    # ========================================
    # REMOVED COLUMNS (replaced by state jsonb):
    # - active_task_name → now in state['active_task']
    # - active_task_status → now in state['active_task']
    # ========================================
    
    # Timestamps
    created_at = Column(TIMESTAMP(timezone=True), nullable=False, server_default=func.now())
    updated_at = Column(TIMESTAMP(timezone=True), nullable=False, server_default=func.now())
    
    # ========================================
    # Relationships
    # ========================================
    user = relationship("UserModel", back_populates="sessions")
    instance = relationship("InstanceModel", back_populates="sessions")
    messages = relationship(
        "MessageModel", 
        back_populates="session", 
        cascade="all, delete-orphan", 
        passive_deletes=True
    )
    token_usage = relationship(
        "SessionTokenUsageModel", 
        back_populates="session", 
        cascade="all, delete-orphan", 
        passive_deletes=True
    )
    intent_ledger_entries = relationship(
        "IntentLedgerModel", 
        back_populates="session",
        cascade="all, delete-orphan",
        passive_deletes=True
    )
    
    def __repr__(self):
        return f"<Session(id='{self.id}', user_id='{self.user_id}', active={self.active})>"
    
    def to_dict(self):
        """Convert to dictionary for API responses."""
        return {
            'id': str(self.id),
            'user_id': str(self.user_id),
            'instance_id': str(self.instance_id) if self.instance_id else None,
            'started_at': self.started_at.isoformat() if self.started_at else None,
            'ended_at': self.ended_at.isoformat() if self.ended_at else None,
            'active': self.active,
            'source': self.source,
            'last_message_at': self.last_message_at.isoformat() if self.last_message_at else None,
            'current_turn': self.current_turn,
            'session_summary': self.session_summary,
            'state': self.state,
            'next_narrative': self.next_narrative,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'updated_at': self.updated_at.isoformat() if self.updated_at else None
        }
    
    # Helper methods for state management
    def get_state_value(self, key: str, default=None):
        """Get a value from the state JSONB field."""
        if not self.state:
            return default
        return self.state.get(key, default)
    
    def set_state_value(self, key: str, value):
        """Set a value in the state JSONB field."""
        if not self.state:
            self.state = {}
        self.state[key] = value
    
    def update_state(self, updates: dict):
        """Update multiple values in the state JSONB field."""
        if not self.state:
            self.state = {}
        self.state.update(updates)
    
    def initialize_default_state(self):
        """Initialize state with default structure for new sessions."""
        self.state = {
            'expecting_response': False,
            'answer_sheet': None,
            'active_task': None,
            'previous_intents': [],
            'conversation_context': {},
            'available_signals': [],
            'action_queue': [],
            'current_action_index': 0,
            'queue_paused': False,
            'queue_paused_reason': None,
            'loop_state': None
        }